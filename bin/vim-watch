#!/usr/bin/env python
from __future__ import print_function
import time
import fcntl
import os
import signal
import subprocess
import sys
import logging
import errno

path = os.environ['XDG_RUNTIME_DIR'] + '/vim-watch'

DIRTY = None
def run(trigger, initially_dirty):
	global DIRTY

	try:
		os.makedirs(path)
	except OSError as e:
		if e.errno != errno.EEXIST:
			raise
	else:
		logging.debug("Created: %s", path)

	fd = os.open(path, os.O_RDONLY)

	def get_mtime():
		try:
			return os.stat(os.path.join(path, 'save')).st_mtime
		except OSError:
			return 0
	
	def handler(signum, frame):
		global DIRTY
		DIRTY = True
		logging.debug("handler called")
		fcntl.fcntl(fd, fcntl.F_NOTIFY, fcntl.DN_MODIFY | fcntl.DN_CREATE)

	signal.signal(signal.SIGIO, handler)
	fcntl.fcntl(fd, fcntl.F_SETSIG, 0)
	handler(None, None)
	DIRTY = initially_dirty

	while True:
		if DIRTY:
			DIRTY = False
			mtime = get_mtime()
			logging.debug("current mtime: %s", mtime)
			while True:
				last_mtime = mtime
				# print("File %s modified: %s" % (frame,mtime))
				trigger()

				mtime = get_mtime()
				logging.debug("current mtime: %s", mtime)
				if mtime == last_mtime: break
		else:
			logging.debug("Sleeping")
			time.sleep(10000)
			logging.debug("awoke, dirty=%s", DIRTY)

def vimCall(opts, cmd):
	if opts.no_remote:
		return
	servers = opts.remote
	if not servers:
		servers = subprocess.check_output(['vim', '--serverlist']).decode('utf-8').strip().splitlines()
	failed = 0
	for server in servers:
		proc = subprocess.Popen(['vim', '--servername', server, '--remote-send', '<esc>:%s<cr>' % cmd])
		if proc.wait() != 0:
			failed += 1
			logging.error("Failed to enable `vim-watch` plugin in vim server: %s", server)

	logging.info("invoked %s on %d running vim instances" % (cmd, len(servers) - failed))

class Ref(object):
	def __init__(self, r):
		self.set(r)
	
	def set(self, r):
		self.value = r


def main():
	enabled = False
	huppy = Ref(None)
	try:
		from optparse import OptionParser
		p = OptionParser('Usage: %prog [options] command [ args ... ]')
		p.disable_interspersed_args()
		p.add_option('--no-remote',    '-n', action='store_true', help='disable automatic enabling / disabling of VIM plugin')
		p.add_option('--remote',       '-r', action='append', default=[], help='target a specific VIM server')
		p.add_option('--huppy',        '-s', action='store_true', help='use `huppy` to run / restart a long-running process (mnemonic: [s]erver) (http://gfxmonk.net/dist/0install/huppy.xml)')
		p.add_option('--verbose',      '-v', action='store_true', help='verbose')
		opts, args = p.parse_args()
		assert len(args) > 0

		fmt = '[ watch ] %(message)s'
		lvl = logging.INFO
		if opts.verbose:
			lvl = logging.DEBUG
		logging.basicConfig(format=fmt, level=lvl)

		assert len(args) > 0, "You must provide a command"

		if opts.huppy:
			def start_huppy():
				assert huppy.value is None
				huppy.set(subprocess.Popen([os.environ.get('HUPPY','huppy')] + args))
			# run a long-running huppy process
			logging.info("starting huppy ...")
			start_huppy()
			def check():
				if huppy.value.poll() is not None:
					logging.error("`huppy` process exited - restarting")
					huppy.set(None)
					start_huppy()
					return False
				return True
			check()

			def trigger():
				if check():
					logging.debug("sending SIGHUP")
					try:
						os.kill(huppy.value.pid, signal.SIGHUP)
					except OSError: pass
				check()
		else:
			def trigger():
				returncode = subprocess.Popen(args).wait()
				if returncode != 0:
					logging.warn("Command failed with status %d", returncode)
				else:
					logging.info('--')


		vimCall(opts, "WatchNotify")
		enabled = True
		run(trigger, initially_dirty=not opts.huppy)
	except AssertionError:
		p.print_help()
		sys.exit(2)
	except RuntimeError as e:
		print('Error: %s' % (e,), file=sys.stderr)
		sys.exit(1)
	except KeyboardInterrupt:
		print()
		sys.exit(2)
	finally:
		def cleanup_vim():
			if enabled:
				vimCall(opts, "WatchNotifyOff")
		def cleanup_huppy():
			if huppy.value:
				os.kill(huppy.value.pid, signal.SIGTERM)
				try:
					logging.info("stopping huppy ... ")
					huppy.value.wait()
				except KeyboardInterrupt:
					huppy.value.kill()
					huppy.value.wait()

		failed = False
		for cleanup in [cleanup_vim, cleanup_huppy]:
			try:
				cleanup()
			except Exception as e:
				logging.debug(str(e), exc_info = True)
				logging.error('Error: %s' % (e,), exc_info = True)
				failed = True
		if failed:
			sys.exit(1)

main()
